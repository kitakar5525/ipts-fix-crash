From cc790199e403ed5d1930eab552d8268559ac1eb4 Mon Sep 17 00:00:00 2001
From: "Hayataka@kitakar5525" <Hayataka@kitakar5525>
Date: Thu, 20 Jun 2019 16:19:15 +0900
Subject: [PATCH] ipts: add recovery thread

---
 drivers/misc/ipts/ipts-mei.c | 49 ++++++++++++++++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/drivers/misc/ipts/ipts-mei.c b/drivers/misc/ipts/ipts-mei.c
index 199e49cb8..3d4689121 100644
--- a/drivers/misc/ipts/ipts-mei.c
+++ b/drivers/misc/ipts/ipts-mei.c
@@ -20,6 +20,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/kthread.h>
 #include <linux/intel_ipts_if.h>
+#include <linux/delay.h>
 
 #include "ipts.h"
 #include "ipts-hid.h"
@@ -27,6 +28,7 @@
 #include "ipts-mei-msgs.h"
 #include "ipts-binary-spec.h"
 #include "ipts-state.h"
+#include "../mei/mei_dev.h"
 
 #define IPTS_DRIVER_NAME	"ipts"
 #define IPTS_MEI_UUID		UUID_LE(0x3e8d0870, 0x271a, 0x4208, \
@@ -158,6 +160,52 @@ static int ipts_mei_cl_event_thread(void *data)
 	return 0;
 }
 
+static struct task_struct *recovery_thread;
+
+static int ipts_recovery_thread(void *data)
+{
+	ipts_info_t *ipts = (ipts_info_t *)data;
+	char fw_sts_str[MEI_FW_STATUS_STR_SZ];
+
+	while (!kthread_should_stop()) {
+		mei_fw_status_str(ipts->cldev->bus, fw_sts_str, MEI_FW_STATUS_STR_SZ);
+
+		/*
+		 * When the touch crash happens, the sixth number (zero-based) of `fw_status`
+		 * will become '7'.
+		 * 
+		 * For example:
+		 * 	Before the crash:
+		 * 	A280545D 00990000 583E5805 CAFC0000 00000000 00000000
+		 * 	After the crash:
+		 * 	A280547D 00200000 4A474A41 214B0000 00000000 00000000
+		 * 
+		 * Touch and pen issue persists · Issue #374 · jakeday/linux-surface
+		 * https://github.com/jakeday/linux-surface/issues/374#issuecomment-500646040
+		 */
+		/*
+		 * TODO: One possible problem is...
+		 * the output of fw_status could be completely different between devices.
+		 * '7' could indicate another status on the other devices (?).
+		 */
+		if (fw_sts_str[6] == '7') {
+			ipts_err(ipts, "ME FW malfunction detected. Applying a workaround...");
+			ipts_err(ipts, "For more information, see https://github.com/jakeday/linux-surface/issues/374");
+			ipts_send_sensor_clear_mem_window_cmd(ipts);
+
+			/*
+			 * Need some amount of sleep for `fw_status` to be updated
+			 * Or this block will be called multiple times. (It is harmless, though.)
+			 */
+			msleep(1000);
+		}
+	}
+
+	ipts_dbg(ipts, "!! end recovery_thread loop !!\n");
+
+	return 0;
+}
+
 static void init_work_func(struct work_struct *work)
 {
 	ipts_info_t *ipts = container_of(work, ipts_info_t, init_work);
@@ -203,6 +251,7 @@ static int ipts_mei_cl_probe(struct mei_cl_device *cldev,
 
 	ipts->event_loop = kthread_run(ipts_mei_cl_event_thread, (void*)ipts,
 							"ipts_event_thread");
+	recovery_thread = kthread_run(ipts_recovery_thread, (void *)ipts, "ipts_recovery_thread");
 
 	if(ipts_dbgfs_register(ipts, "ipts"))
 		pr_debug("cannot register debugfs for IPTS\n");
-- 
2.22.0

